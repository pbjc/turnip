#!/usr/bin/ruby
require 'sqlite3'

USAGE = <<EOS
usage: papet [--help] <command> [<args>]

Record when you work during the day.

Commands:
  start start the clock
  stop  stop the clock
  show  display all saved intervals
  clear delete all saved intervals
EOS

DB_DIR = '.papet'
DB_FILE = 'intervals.db'
DATE_DB_FORMAT = '%Y%m%d'
DATE_PRINT_FORMAT = '%b %d, %Y'
TIME_DB_FORMAT = '%H:%M'
TIME_PRINT_FORMAT = '%I:%M %p'
SECS_IN_HOUR = 60 * 60

def format_db_date(db_date_str)
  return '' if db_date_str.nil?
  Date.strptime(db_date_str, DATE_DB_FORMAT).strftime(DATE_PRINT_FORMAT)
end

def format_db_time(db_time_str)
  return '' if db_time_str.nil?
  Time.strptime(db_time_str, TIME_DB_FORMAT).strftime(TIME_PRINT_FORMAT)
end

def get_hours_worked(start_time, end_time)
  return (end_time - start_time) / SECS_IN_HOUR
end

def show_usage
  puts USAGE
end

def setup_db
  Dir.chdir(ENV['HOME'])
  Dir.mkdir(DB_DIR) unless File::exists?(DB_DIR)
  Dir.chdir(DB_DIR)
  db_exists = File::exists?(DB_FILE)
  db = SQLite3::Database.new DB_FILE

  if db_exists
    db.execute(<<-SQL) do |last_row|
      select * from intervals
      order by rowid desc
      limit 1;
    SQL

      # TODO: handle forgotten punch out
    end
  else
    # TODO: add index on date
    db.execute <<-SQL
      create table intervals (
        date  date,
        start time,
        end   time
      );
    SQL
  end

  db
end

def punch_in(db)
  db.execute(<<-SQL) do |last_interval|
    select start, end from intervals
    order by rowid desc
    limit 1;
  SQL

    if last_interval.last.nil?
      puts "You already punched in at #{format_db_time(last_interval.first)}"
      return
    end
  end

  now = Time.now
  db.execute <<-SQL, now.strftime(DATE_DB_FORMAT), now.strftime(TIME_DB_FORMAT)
    insert into intervals (date, start)
    values (?, ?);
  SQL

  puts "Punched in at #{now.strftime(TIME_PRINT_FORMAT)}"
end

def punch_out(db)
  start_time = nil

  db.execute(<<-SQL) do |last_interval|
    select start, end from intervals
    order by rowid desc
    limit 1;
  SQL

    start_time = Time.strptime(last_interval.first, TIME_DB_FORMAT)
    last_interval = last_interval.map(&method(:format_db_time))
    unless last_interval.last.empty?
      puts "You already punched out at #{last_interval.last}"
      return
    end
  end

  end_time = Time.now
  db.execute <<-SQL, end_time.strftime(TIME_DB_FORMAT)
    update intervals
    set end = ?
    order by rowid desc
    limit 1;
  SQL

  hours_worked = get_hours_worked(start_time, end_time)
  print "Worked from #{start_time.strftime(TIME_PRINT_FORMAT)} - "
  print "#{end_time.strftime(TIME_PRINT_FORMAT)} "
  puts "(#{hours_worked.round(2)} hours)"
end

def show_intervals(db)
  dates = db.execute <<-SQL
    select distinct date from intervals
    order by date;
  SQL

  dates.each do |db_date|
    hours_worked = 0
    print_lines = []
    print_lines.push "#{format_db_date(db_date.first.to_s)} | "

    db.execute(<<-SQL, db_date) do |interval|
      select start, end from intervals
      where date = ?
      order by start;
    SQL

      punched_in = interval.last.nil?
      parsed_interval = interval.map do |time_str|
        time_str.nil? ? nil : Time.strptime(time_str, TIME_DB_FORMAT)
      end
      parsed_interval[1] ||= Time.now
      hours_worked += get_hours_worked(*parsed_interval)
      print_lines.push "#{format_db_time(interval.first)} - "
      print_lines.last << (punched_in ? 'now' : format_db_time(interval.last))
    end

    print_lines.first << "Worked for #{hours_worked.round(2)} hours"
    print_lines.each { |str| puts str }
  end
end

def clear_intervals(db)
  db.execute 'delete from intervals;'
  puts 'Cleared all intervals'
end

args = ARGV.map(&:dup)

if args.length == 0 || args[0] == '--help'
  show_usage
  Process.exit
end

db = setup_db

command = args.shift
case command
when 'start'  then punch_in(db)
when 'stop'   then punch_out(db)
when 'show'   then show_intervals(db)
when 'clear'  then clear_intervals(db)
else show_usage
end
